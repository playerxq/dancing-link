// hdu-2518-精确覆盖.cpp : 定义控制台应用程序的入口点。
//60个格子  12个图形组成72列 精确覆盖
//行是每个图形的每种放置方式（旋转）在不同的中心点时格子占用情况
#include "stdafx.h"
#include <cstdio>
#include <iostream>
#include <string.h>
#include <math.h>
#include <vector>
#include<iomanip>
#include <ctype.h>
#include <algorithm>
using namespace std;
#define MAXN 5810
#define MAXM 80
#define MAXD 35510
#define INF 0x3f3f3f3f
#define HASH 100007
#define SIZE 100010
typedef long long LL;
//x表示行偏移 y为列偏移
//定义中心点为每个图形最上面最左面的点 随着旋转  中心点也改变
//每个图形5个点  中心点外4个点
//对每个图形的8中旋转  关于中心点的x的偏移
//d = 8 共8种旋转 12个图形  4个外点
int dx[8][12][4] =
{
    {// 0 原图
        {1, 2, 2, 2}, // 1
        {0, 0, 0, 0}, // 2
        {1, 1, 1, 2}, // 3
        {0, 1, 1, 1}, // 4
        {1, 1, 1, 1}, // 5
        {1, 1, 2, 2}, // 6
        {1, 1, 1, 1}, // 7
        {1, 1, 1, 2}, // 8
        {1, 1, 2, 2}, // 9
        {1, 2, 2, 2}, // 10
        {0, 1, 1, 1}, // 11
        {0, 0, 1, 1}, // 12
    },
    {// 1
        {1, 2, 2, 2}, // 1
        {1, 2, 3, 4}, // 2
        {1, 1, 1, 2}, // 3
        {0, 1, 2, 2}, // 4
        {1, 2, 3, 3}, // 5
        {1, 1, 2, 2}, // 6
        {1, 2, 2, 3}, // 7
        {0, 1, 2, 2}, // 8
        {1, 1, 1, 2}, // 9
        {1, 1, 1, 2}, // 10
        {0, 1, 1, 2}, // 11
        {1, 2, 2, 3}, // 12
    },
    {// 2
        {0, 0, 1, 2}, // 1
        {0, 0, 0, 0}, // 2
        {1, 1, 1, 2}, // 3
        {0, 0, 1, 1}, // 4
        {0, 0, 0, 1}, // 5
        {0, 1, 1, 2}, // 6
        {0, 0, 0, 1}, // 7
        {1, 1, 1, 2}, // 8
        {0, 1, 1, 2}, // 9
        {0, 0, 1, 2}, // 10
        {0, 0, 1, 1}, // 11
        {0, 1, 1, 1}, // 12
    },
    {// 3
        {0, 0, 1, 2}, // 1
        {1, 2, 3, 4}, // 2
        {1, 1, 1, 2}, // 3
        {0, 1, 2, 2}, // 4
        {0, 1, 2, 3}, // 5
        {0, 1, 1, 2}, // 6
        {1, 1, 2, 3}, // 7
        {0, 1, 2, 2}, // 8
        {1, 1, 1, 2}, // 9
        {1, 1, 1, 2}, // 10
        {1, 1, 2, 2}, // 11
        {1, 1, 2, 3}, // 12
    },
    {// 4
        {1, 2, 2, 2}, // 1
        {0, 0, 0, 0}, // 2
        {1, 1, 1, 2}, // 3
        {0, 1, 1, 1}, // 4
        {1, 1, 1, 1}, // 5
        {1, 1, 2, 2}, // 6
        {1, 1, 1, 1}, // 7
        {1, 1, 1, 2}, // 8
        {1, 1, 2, 2}, // 9
        {1, 2, 2, 2}, // 10
        {0, 1, 1, 1}, // 11
        {0, 0, 1, 1}, // 12
    },
    {// 5
        {0, 0, 1, 2}, // 1
        {1, 2, 3, 4}, // 2
        {1, 1, 1, 2}, // 3
        {0, 1, 2, 2}, // 4
        {0, 1, 2, 3}, // 5
        {0, 1, 1, 2}, // 6
        {1, 1, 2, 3}, // 7
        {0, 1, 2, 2}, // 8
        {1, 1, 1, 2}, // 9
        {1, 1, 1, 2}, // 10
        {1, 1, 2, 2}, // 11
        {1, 1, 2, 3}, // 12
    },
    {// 6
        {0, 0, 1, 2}, // 1
        {0, 0, 0, 0}, // 2
        {1, 1, 1, 2}, // 3
        {0, 0, 1, 1}, // 4
        {0, 0, 0, 1}, // 5
        {0, 1, 1, 2}, // 6
        {0, 0, 0, 1}, // 7
        {1, 1, 1, 2}, // 8
        {0, 1, 1, 2}, // 9
        {0, 0, 1, 2}, // 10
        {0, 0, 1, 1}, // 11
        {0, 1, 1, 1}, // 12
    },
    {// 7
        {1, 2, 2, 2}, // 1
        {1, 2, 3, 4}, // 2
        {1, 1, 1, 2}, // 3
        {0, 1, 2, 2}, // 4
        {1, 2, 3, 3}, // 5
        {1, 1, 2, 2}, // 6
        {1, 2, 2, 3}, // 7
        {0, 1, 2, 2}, // 8
        {1, 1, 1, 2}, // 9
        {1, 1, 1, 2}, // 10
        {0, 1, 1, 2}, // 11
        {1, 2, 2, 3}, // 12
    },
};
//对每个图形的8中旋转   关于中心点的y的偏移
int dy[8][12][4] =
{
    {// 0
        {0, 0, 1, 2}, // 1
        {1, 2, 3, 4}, // 2
        {-1, 0, 1, 0}, // 3
        {2, 0, 1, 2}, // 4
        {0, 1, 2, 3}, // 5
        {0, 1, 1, 2}, // 6
        {-1, 0, 1, 2}, // 7
        {-2, -1, 0, -2}, // 8
        {0, 1, -1, 0}, // 9
        {0, -1, 0, 1}, // 10
        {1, -1, 0, 1}, // 11
        {1, 2, -1, 0}, // 12
    },
    {// 1 逆时针90
        {0, -2, -1, 0}, // 1
        {0, 0, 0, 0}, // 2
        {-1, 0, 1, 0}, // 3
        {1, 1, 0, 1}, // 4
        {0, 0, 0, -1}, // 5
        {-1, 0, -2, -1}, // 6
        {0, -1, 0, 0}, // 7
        {1, 1, 1, 2}, // 8
        {-1, 0, 1, 1}, // 9
        {-2, -1, 0, 0}, // 10
        {1, 0, 1, 1}, // 11
        {0, 0, 1, 1}, // 12
    },
    {// 2 再逆时针90
        {1, 2, 2, 2}, // 1
        {1, 2, 3, 4}, // 2
        {-1, 0, 1, 0}, // 3
        {1, 2, 0, 2}, // 4
        {1, 2, 3, 3}, // 5
        {1, 1, 2, 2}, // 6
        {1, 2, 3, 2}, // 7
        {-2, -1, 0, -2}, // 8
        {1, -1, 0, 0}, // 9
        {1, 2, 1, 1}, // 10
        {1, 2, 0, 1}, // 11
        {1, -2, -1, 0}, // 12
    },
    {// 3 //再逆时针90
        {1, 2, 0, 0}, // 1
        {0, 0, 0, 0}, // 2
        {-1, 0, 1, 0}, // 3
        {1, 0, 0, 1}, // 4
        {1, 0, 0, 0}, // 5
        {1, -1, 0, -1}, // 6
        {0, 1, 0, 0}, // 7
        {1, 1, 1, 2}, // 8
        {0, 1, 2, 1}, // 9
        {0, 1, 2, 0}, // 10
        {0, 1, 0, 1}, // 11
        {0, 1, 1, 1}, // 12
    },
    {// 4 原图翻转
        {0, -2, -1, 0}, // 1
        {1, 2, 3, 4}, // 2
        {-1, 0, 1, 0}, // 3
        {2, 0, 1, 2}, // 4
        {-3, -2, -1, 0}, // 5
        {-1, 0, -2, -1}, // 6
        {-2, -1, 0, 1}, // 7
        {0, 1, 2, 2}, // 8
        {-1, 0, 0, 1}, // 9
        {0, -1, 0, 1}, // 10
        {1, 0, 1, 2}, // 11
        {1, 2, 2, 3}, // 12
    },
    {// 5 翻转后逆时针90
        {1, 2, 2, 2}, // 1
        {0, 0, 0, 0}, // 2
        {-1, 0, 1, 0}, // 3
        {1, 1, 0, 1}, // 4
        {1, 1, 1, 1}, // 5
        {1, 1, 2, 2}, // 6
        {-1, 0, 0, 0}, // 7
        {-1, -1, -2, -1}, // 8
        {-2, -1, 0, -1}, // 9
        {-2, -1, 0, 0}, // 10
        {-1, 0, -1, 0}, // 11
        {-1, 0, -1, -1}, // 12
    },
    {// 6 再逆时针90
        {1, 2, 0, 0}, // 1
        {1, 2, 3, 4}, // 2
        {-1, 0, 1, 0}, // 3
        {1, 2, 0, 2}, // 4
        {1, 2, 3, 0}, // 5
        {1, -1, 0, -1}, // 6
        {1, 2, 3, 1}, // 7
        {0, 1, 2, 2}, // 8
        {1, 1, 2, 1}, // 9
        {1, 2, 1, 1}, // 10
        {1, 2, 1, 2}, // 11
        {1, 1, 2, 3}, // 12
    },
    {// 7 再逆时针90
        {0, 0, 1, 2}, // 1
        {0, 0, 0, 0}, // 2
        {-1, 0, 1, 0}, // 3
        {1, 0, 0, 1}, // 4
        {0, 0, 0, 1}, // 5
        {0, 1, 1, 2}, // 6
        {0, 0, 1, 0}, // 7
        {1, 0, -1, 0}, // 8
        {-1, 0, 1, -1}, // 9
        {0, 1, 2, 0}, // 10
        {1, 0, 1, 0}, // 11
        {0, -1, 0, -1}, // 12
    },
};
//dx dy数组包含了12个图形的所有旋转方式
struct HashMap//hash表保存已经有的旋转或者翻转
{
    int head[HASH], size, next[SIZE];
    LL st[SIZE];
    void init()
    {
        memset(head, -1, sizeof(head)), size = 0;
    }
    int find(LL _st)//查找
    {
        int i, h = (_st & 0x7fffffff) % HASH;
        for(i = head[h]; i != -1; i = next[i])
            if(_st == st[i]) break;
        return i;
    }
    void push(LL _st)//插入
    {
        int i, h = (_st & 0x7fffffff) % HASH;
        st[size] = _st;//增加一个值
        next[size] = head[h], head[h] = size ++;//保存索引
    }
}hm;
struct Info
{
    int d, id, x, y;
}info[MAXD];
int N, M, size, U[MAXD], D[MAXD], L[MAXD], R[MAXD], C[MAXD], Q[MAXN], ANS;
int S[MAXM], H[MAXN], g[MAXM][MAXM], t[MAXM][MAXM];
LL fac[MAXM], f[MAXM];//fac[i]=19^i   f[i]=61^i
inline int inside(int x, int y)
{
    return x >= 1 && x <= N && y >= 1 && y <= M;
}
void build(int m)
{
    int i;
    for(i = 0; i <= m; i ++)
    {
        U[i] = D[i] = i;
        L[i + 1] = i, R[i] = i + 1;
        S[i] = 0;
    }
    R[m] = 0, size = m;
    memset(H, -1, sizeof(H));
}
void insert(int r, int c, int d, int id, int x, int y)//在Link基础上，增加对info的赋值
{
    ++ size;
    C[size] = c, ++ S[c];
    D[size] = D[c], U[size] = c;
    U[D[c]] = size, D[c] = size;
    if(H[r] == -1) H[r] = L[size] = R[size] = size;
    else
    {
        R[size] = R[H[r]], L[size] = H[r];
        L[R[H[r]]] = size, R[H[r]] = size;
    }
    info[size].d = d, info[size].id = id, info[size].x = x, info[size].y = y;//x,y为中心点 第size号节点代表的图形信息
}
inline int place(int d, int id, int x, int y)
{
    int i;
    for(i = 0; i < 4; i ++)//判断id号方块的d号放置方式能否放置在界限内
        if(!inside(x + dx[d][id][i], y + dy[d][id][i])) return 0;
    return 1;
}
int appear(int d, int id, int x, int y)//计算id号方块的d号放置方式，在中心点为(x,y)时占用的格子对应的hash值是否在hash表中出现  判断是否重复
{
    int i;
    LL ans = (x - 1) * M + y;
    for(i = 0; i < 4; i ++) ans += f[i + 1] * ((x + dx[d][id][i] - 1) * M + y + dy[d][id][i]);//用素数61做阶乘 由于一共60个格子 x,y的最大和就是60 取大于60的最小素数61
    if(hm.find(ans) != -1) return 1;
    hm.push(ans);
    return 0;
}
void init()
{
    int i, j, k, d, id, r = 0, c;
    build(N * M + 12);
    hm.init();
    for(d = 0; d < 8; d ++)//对每种放置方式  即旋转或者翻转   一共最多8个 即原图转一圈4个 翻转再转一圈4个
	{
        for(id = 0; id < 12; id ++)//每个方块
		{
			//中心(i,j)点
            for(i = 1; i <= N; i ++)//行
			{
                for(j = 1; j <= M; j ++)//列
				{
                    if(place(d, id, i, j) && !appear(d, id, i, j))//可以放置且未出现过
                    {
                        ++ r;//新行
						//前1：12列是每个方块，格子号 13：72列是代表每个格子 从0号方块开始计算 即id+1列
                        insert(r, id + 1, d, id, i, j);
						//中心格子为(i-1)*M+j+12
						insert(r, (i - 1) * M + j + 12, d, id, i, j);
						//除中心格子以外的格子
                        for(k = 0; k < 4; k ++)
                        {
                            c = (i + dx[d][id][k] - 1) * M + j + dy[d][id][k] + 12;//格子号
                            insert(r, c, d, id, i, j);
                        }
                    }
				}
			}
		}
	}
}
void remove(int c)
{
	L[R[c]]=L[c];
	R[L[c]]=R[c];
	for(int i = D[c];i!=c;i=D[i])
	{
		for(int j = R[i];j!=i;j=R[j])
		{
			U[D[j]]=U[j];
			D[U[j]]=D[j];
			--S[C[j]];
		}
	}
}
void resume(int c)
{
	for(int i = U[c];i!=c;i=U[i])
	{
		for(int j = L[i];j!=i;j=L[j])
		{
			U[D[j]]=j;
			D[U[j]]=j;
			++S[C[j]];
		}
	}
	L[R[c]]=c;
	R[L[c]]=c;
}
LL encode(int g[][MAXM])
{
    int i, j, k = 0;
    LL ans = 0;
    for(i = 1; i <= N; i ++)
        for(j = 1; j <= M; j ++)
            ans += fac[k ++] * g[i][j];//使用素数19编码
    return ans;
}
void deal(int dep)//计算得到的方块摆放方式
{
    int i, j, k, d, id, x, y, flag = 0;
    LL ans;
    for(k = 0; k < dep; k ++)
    {
        j = Q[k];//Q保存的是舞蹈连中的方块号
        d = info[j].d, id = info[j].id, x = info[j].x, y = info[j].y;//获取这个方块代表的原图方块的信息 x,y为中心点
        g[x][y] = id;//将重心点位置标记块号
        for(i = 0; i < 4; i ++) g[x + dx[d][id][i]][y + dy[d][id][i]] = id;//对周围四个点也标记id
    }
    ans = encode(g);//对当前完整图编码
    if(hm.find(ans) != -1) return;//新计算的图
	//之前获取过
	//对图形旋转3次  如果有某次旋转得到以前的图  说明是重复答案
	//t=原图原点翻转
    for(i = 1, x = N; i <= N; i ++, x --)
        for(j = 1, y = M; j <= M; j ++, y --) t[x][y] = g[i][j];
    ans = encode(t);
    if(hm.find(ans) != -1) return;
	//t=原图关于竖轴翻转
    for(i = 1; i <= N; i ++)
        for(j = 1, y = M; j <= M; j ++, y --) t[i][y] = g[i][j];
    ans = encode(t);
	//t=原图关于横轴翻转
    if(hm.find(ans) != -1) return;
    for(i = 1, x = N; i <= N; i ++, x --)
        for(j = 1; j <= M; j ++) t[x][j] = g[i][j];
    ans = encode(t);
    if(hm.find(ans) != -1) return;
    ++ ANS, hm.push(encode(g));//均未重复  得到一个新的解
}

void Dance(int k)
{
	int i,j,Min,c;
	if(R[0]==0)
	{
		deal(k);
		return;
	}
	for(Min=INF,i=R[0];i;i=R[i])//选取最小的1数目所在的列
         if(Min>S[i]) Min=S[i],c=i;
	remove(c);
	for(i=D[c];i!=c;i=D[i])//假设i所在的行选择  则该行上的1所在的列上每个1所在的行不可能选中 因此将这些列remove掉 即去除列上1所在的行
     {
         for(j=R[i];j!=i;j=R[j])
             remove(C[j]);
         Q[k]=i;//记录选择号
         Dance(k+1);
         for(j=L[i];j!=i;j=L[j])
             resume(C[j]);
     }
     resume(c);
}
void solve()
{
    ANS = 0;
    hm.init();
    Dance(0);
    printf("%d\n", ANS);
}
int main()
{
    freopen("input.txt","r",stdin);
    freopen("output.txt","w",stdout);
	fac[0] = f[0] = 1;
    for(int i = 1; i <= 60; i ++) fac[i] = fac[i - 1] * 19, f[i] = f[i - 1] * 61;
    while(scanf("%d%d", &N, &M) == 2)
    {
        init();
        solve();
    }
    return 0;
}

