// 数独模板.cpp : 定义控制台应用程序的入口点。
//
/*
第1列定义成：（1，1）填了一个数字

第2列定义成：（1，2）填了一个数字

……

第9列定义成：（1，9）填了一个数字

第10列定义成：（2，1）填了一个数字

……

第18列定义成：（2，9）填了一个数字

……

第81列定义成：（9，9）填了一个数字

至此，用第1-81列完成了约束条件1：每个格子只能填一个数字

第N列（1≤N≤81）定义成：（X，Y）填了一个数字。

N、X、Y之间的关系是：X=INT（（N-1）/9）+1；Y=（（N-1） Mod 9）+1；N=（X-1）×9+Y

 

 

第82列定义成：在第1行填了数字1

第83列定义成：在第1行填了数字2

……

第90列定义成：在第1行填了数字9

第91列定义成：在第2行填了数字1

……

第99列定义成：在第2行填了数字9

……

第162列定义成：在第9行填了数字9

至此，用第82-162列（共81列）完成了约束条件2：每行1-9的这9个数字都得填一遍

第N列（82≤N≤162）定义成：在第X行填了数字Y。

N、X、Y之间的关系是：X=INT（（N-81-1）/9）+1；Y=（（N-81-1） Mod 9）+1；N=（X-1）×9+Y+81

 

 

第163列定义成：在第1列填了数字1

第164列定义成：在第1列填了数字2

……

第171列定义成：在第1列填了数字9

第172列定义成：在第2列填了数字1

……

第180列定义成：在第2列填了数字9

……

第243列定义成：在第9列填了数字9

至此，用第163-243列（共81列）完成了约束条件3：每列1-9的这9个数字都得填一遍

第N列（163≤N≤243）定义成：在第X列填了数字Y。

N、X、Y之间的关系是：X=INT（（N-162-1）/9）+1；Y=（（N-162-1） Mod 9）+1；N=（X-1）×9+Y+162

 

 

第244列定义成：在第1宫填了数字1

第245列定义成：在第1宫填了数字2

……

第252列定义成：在第1宫填了数字9

第253列定义成：在第2宫填了数字1

……

第261列定义成：在第2宫填了数字9

……

第324列定义成：在第9宫填了数字9

至此，用第244-324列（共81列）完成了约束条件4：每宫1-9的这9个数字都得填一遍

第N列（244≤N≤324）定义成：在第X宫填了数字Y。

N、X、Y之间的关系是：X=INT（（N-243-1）/9）+1；Y=（（N-243-1） Mod 9）+1；N=（X-1）×9+Y+243

在（4，2）中填的是7

把（4，2）中填的是7，解释成4个约束条件

1、在（4，2）中填了一个数字。

2、在第4行填了数字7

3、在第2列填了数字7

4、在第4宫填了数字7（坐标（X，Y）到宫N的公式为：N=INT（（X-1）/3）×3+INT（（Y-1）/3）+1）

 

那么这4个条件，分别转换成矩阵对应的列为

1、在（4，2）中填了一个数字。对应的列N=（4-1）×9+2=29

2、在第4行填了数字7。对应的列N=（4-1）×9+7+81=115

3、在第2列填了数字7。对应的列N=（2-1）×9+7+162=178

4、在第4宫填了数字7。对应的列N=（4-1）×9+7+243=277

 

于是，（4，2）中填的是7，转成矩阵的一行就是，第29、115、178、277列是1，其余列是0。把这1行插入到矩阵中去。

 

没数字的格子

还是举例说明，在（5，8）中没有数字

把（5，8）中没有数字转换成

（5，8）中填的是1，转成矩阵的一行就是，第44、118、226、289列是1，其余列是0。

（5，8）中填的是2，转成矩阵的一行就是，第44、119、227、290列是1，其余列是0。

（5，8）中填的是3，转成矩阵的一行就是，第44、120、228、291列是1，其余列是0。

（5，8）中填的是4，转成矩阵的一行就是，第44、121、229、292列是1，其余列是0。

（5，8）中填的是5，转成矩阵的一行就是，第44、122、230、293列是1，其余列是0。

（5，8）中填的是6，转成矩阵的一行就是，第44、123、231、294列是1，其余列是0。

（5，8）中填的是7，转成矩阵的一行就是，第44、124、232、295列是1，其余列是0。

（5，8）中填的是8，转成矩阵的一行就是，第44、125、233、296列是1，其余列是0。

（5，8）中填的是9，转成矩阵的一行就是，第44、126、234、297列是1，其余列是0。

把这9行插入到矩阵中。由于这9行的第44列都是1（不会有其他行的44列会是1）
也就是说这9行中必只有1行（有且只有1行）选中（精确覆盖问题的定义，每列只能有1个1），是最后解的一部分。
这就保证了最后解在（5，8）中只有1个数字。
*/

#include "stdafx.h"
#include <cstdio>
#include <iostream>
#include <string.h>
#include <math.h>
#include <vector>
#include<iomanip>
#include <ctype.h>
#include <algorithm>
using namespace std;
#define RR 750//空的位置可以扩展为9行  最多81个空位
#define CC 350//列约束在324
#define V RR*CC
int hashx1[RR],hashx2[RR],hashx[RR],OK[90];//解有81行  因为81个格子  每个格子对应一行
int U[V],R[V],L[V],D[V];
int C[V],Row[V];
int H[RR],S[CC];
int map[10][10];
int size,r;
void remove(int c)
{
	R[L[c]]=R[c];
	L[R[c]]=L[c];
	for(int i = D[c];i!=c;i=D[i])
	{
		for(int j = R[i];j!=i;j=R[j])
		{
			U[D[j]]=U[j];
			D[U[j]]=D[j];
			--S[C[j]];
		}
	}
}
void resume(int c)
{
	for(int i = U[c];i!=c;i=U[i])
	{
		for(int j = L[i];j!=i;j=L[j])
		{
			U[D[j]]=j;
			D[U[j]]=j;
			++S[C[j]];
		}
	}
	R[L[c]]=c;
	L[R[c]]=c;
}
void Link(int r, int c)
{
	S[c]++;
	C[size]=c;
	Row[size]=r;
	U[size]=U[c];
	D[U[c]]=size;
	D[size]=c;
	U[c]=size;
	if(H[r]==-1) H[r]=L[size]=R[size]=size;
	else
	{
		L[size]=L[H[r]];
		R[L[H[r]]]=size;
		R[size]=H[r];
		L[H[r]]=size;
	}
	++size;
}
int get_ans()//得到一组解  就是一组行
{
    int i;
    for(i=0;i<81;i++)//对得到的每一行 OK[i] hashx1记录这行代表的真实行 hashx2记录真实列 hashx记录值
         map[hashx1[OK[i]]][hashx2[OK[i]]]=hashx[OK[i]];
	return 0;
}
int Dance(int k)
{
	int i,j,Min,c;
	if(R[0]==0)
	{
		get_ans();
		return 1;
	}
	for(Min=RR,i=R[0];i;i=R[i])//选取最小的1数目所在的列
	{
		if(Min>S[i]) {Min=S[i];c=i;}
	}
	remove(c);
	for(i=D[c];i!=c;i=D[i])//假设i所在的行选择  则该行上的1所在的列上每个1所在的行不可能选中 因此将这些列remove掉 即去除列上1所在的行
     {
         for(j=R[i];j!=i;j=R[j])
             remove(C[j]);
         OK[k]=Row[i];//记录选择的行
         if(Dance(k+1)) return 1;
         for(j=L[i];j!=i;j=L[j])
             resume(C[j]);
     }
     resume(c);
	 return 0;
}
int main()
{
    freopen("input.txt","r",stdin);
    freopen("output.txt","w",stdout);
	
	for(int i = 0;i<=324;i++)
	{
		S[i]=0;
		R[i]=i+1;
		L[i+1]=i;
		U[i]=D[i]=i;
	}
	R[324]=0;
	size = 325;
	memset(H,-1,sizeof(H));
	memset(map,0,sizeof(map));
	r = 0;
	for(int i = 1;i<=9;i++)
	{
		for(int j = 1;j<=9;j++)
			scanf("%d",&map[i][j]);
	}
	for(int i = 1;i<=9;i++)
	{
		for(int j = 1;j<=9;j++)
		{
			if(map[i][j]!=0)
			{
				r++;//新增一行
				hashx1[r]=i;
                hashx2[r]=j;
                hashx[r]=map[i][j];//记录下值
				Link(r,(i-1)*9+j);//(i,j)格填一个数 对应列(i-1)*9+j
				Link(r,(i-1)*9+map[i][j]+81);//i行填map[i][j]
				Link(r,(j-1)*9+map[i][j]+162);//j列填map[i][j]
				int g = int((i-1)/3*3+int((j-1)/3))+1;
				Link(r,243+((i-1)/3)*27 + ((j-1)/3)*9+map[i][j]);//g宫填map[i][j]
			}
			else
			{
				//枚举(i,j)中填1:9
				for(int k = 1;k<=9;k++)
				{
					r++;
					hashx1[r]=i;
                    hashx2[r]=j;
                    hashx[r]=k;//记录下值
					Link(r,(i-1)*9+j);//(i,j)格填一个数 对应列(i-1)*9+j
					Link(r,(i-1)*9+k+81);//i行填map[i][j]
					Link(r,(j-1)*9+k+162);//j列填map[i][j]
					int g = int((i-1)/3*3+int((j-1)/3))+1;
					Link(r,243+(i-1)/3*27 + (j-1)/3*9 + k);//g宫填map[i][j]
				}
			}
		}
	}
	Dance(0);
	for(int i = 1;i<=9;i++)
	{
		for(int j = 1;j<=9;j++)
		{
			printf("%d ",map[i][j]);
		}
		printf("\n");
	}
}

